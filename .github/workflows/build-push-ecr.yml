name: Build, Push to ECR, and Deploy to ECS

on:
  push:
    branches:
      - main
      - develop
      - dev
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: python-flask
  CLUSTER_NAME_DEV: python-flask-cluster-dev
  CLUSTER_NAME_PROD: python-flask-cluster-prod
  SERVICE_NAME_DEV: python-flask-service-dev
  SERVICE_NAME_PROD: python-flask-service-prod
  TASK_FAMILY_DEV: python-flask-dev
  TASK_FAMILY_PROD: python-flask-prod

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    outputs:
      image: ${{ steps.image.outputs.image }}
      registry: ${{ steps.login-ecr.outputs.registry }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f .docker/Dockerfile.prod .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Output image URI
        id: image
        run: |
          # Get ECR registry from login
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=${{ github.sha }}
          
          if [ -z "$ECR_REGISTRY" ]; then
            echo "ERROR: ECR_REGISTRY is empty, using alternative method"
            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          fi
          
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          
          echo "image=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Registry: ${ECR_REGISTRY}"
          echo "Repository: ${ECR_REPOSITORY}"
          echo "Tag: ${IMAGE_TAG}"
          echo "Full Image URI: ${IMAGE_URI}"

  deploy-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/dev'

    permissions:
      id-token: write
      contents: read
    
    env:
      IMAGE_URI: ${{ needs.build-and-push.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to ECS (Dev)
        run: |
          echo "Deploying image: ${IMAGE_URI}"
          
          if [ -z "${IMAGE_URI}" ]; then
            echo "ERROR: IMAGE_URI is empty"
            exit 1
          fi
          
          # Get the latest task definition
          TASK_DEF=$(aws ecs describe-task-definition --task-definition ${{ env.TASK_FAMILY_DEV }} --region ${{ env.AWS_REGION }} --query 'taskDefinition' --output json)
          
          # Update the image in the task definition
          NEW_TASK_DEF=$(echo "${TASK_DEF}" | jq --arg IMAGE "${IMAGE_URI}" '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register the new task definition
          NEW_TASK_DEF_ARN=$(echo "${NEW_TASK_DEF}" | aws ecs register-task-definition --cli-input-json file:///dev/stdin --region ${{ env.AWS_REGION }} --query 'taskDefinition.taskDefinitionArn' --output text)
          
          # Update the service
          aws ecs update-service --cluster ${{ env.CLUSTER_NAME_DEV }} --service ${{ env.SERVICE_NAME_DEV }} --task-definition ${NEW_TASK_DEF_ARN} --region ${{ env.AWS_REGION }}

          echo "Deployment to Dev complete. Task Definition: ${NEW_TASK_DEF_ARN}"

  deploy-prod:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    permissions:
      id-token: write
      contents: read

    environment:
      name: production
      url: https://${{ steps.alb.outputs.dns_name }}
    
    env:
      IMAGE_URI: ${{ needs.build-and-push.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to ECS (Prod)
        run: |
          echo "Deploying image: ${IMAGE_URI}"
          
          if [ -z "${IMAGE_URI}" ]; then
            echo "ERROR: IMAGE_URI is empty"
            exit 1
          fi
          
          # Get the latest task definition
          TASK_DEF=$(aws ecs describe-task-definition --task-definition ${{ env.TASK_FAMILY_PROD }} --region ${{ env.AWS_REGION }} --query 'taskDefinition' --output json)
          
          # Update the image in the task definition
          NEW_TASK_DEF=$(echo "${TASK_DEF}" | jq --arg IMAGE "${IMAGE_URI}" '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register the new task definition
          NEW_TASK_DEF_ARN=$(echo "${NEW_TASK_DEF}" | aws ecs register-task-definition --cli-input-json file:///dev/stdin --region ${{ env.AWS_REGION }} --query 'taskDefinition.taskDefinitionArn' --output text)
          
          # Update the service
          aws ecs update-service --cluster ${{ env.CLUSTER_NAME_PROD }} --service ${{ env.SERVICE_NAME_PROD }} --task-definition ${NEW_TASK_DEF_ARN} --region ${{ env.AWS_REGION }} --force-new-deployment

          echo "Deployment to Prod complete. Task Definition: ${NEW_TASK_DEF_ARN}"

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable --cluster ${{ env.CLUSTER_NAME_PROD }} --services ${{ env.SERVICE_NAME_PROD }} --region ${{ env.AWS_REGION }}

          echo "ECS service is stable and running"

